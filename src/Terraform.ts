import { Base, ApplyOptions, OutputOptions, DestroyOptions, ExecuteOptions } from './Base'
import { SimpleOutputObject, OutputObject, TerraformMultipleOutput, TerraformSingleOutput, SimpleOutput, Output, ResourceCounts, ChangeTypes } from './Types'

class Terraform extends Base {
  constructor() {
    super('terraform', '-auto-approve')
    this.addTriggerWordForInteractiveMode('Only \'yes\' will be accepted to approve')
    this.addTriggerWordForInteractiveMode('Only \'yes\' will be accepted to confirm')
  }
  public async init(path: string, options: ExecuteOptions = { silent: true }) {
    await this.executeSync(path, 'init', { silent: options.silent })
  }

  public async output(path: string, options: OutputOptions = {}): Promise<SimpleOutputObject | OutputObject> {
    const parsedOptions = this.parseOutputOptions(options)
    const { stdout } = await this.executeSync(path, 'output -json', { silent: parsedOptions.silent })
    const output = <TerraformMultipleOutput>JSON.parse(stdout)
    if (options.simple) {
      const keys = Object.keys(output)
      const result = {}
      keys.forEach((key) => {
        result[key] = output[key].value
      })
      return result
    }
    return output
  }

  public async outputValue(path: string, value: string, options: OutputOptions = {}): Promise<SimpleOutput | Output> {
    const parsedOptions = this.parseOutputOptions(options)
    const { stdout } = await this.executeSync(path, `output -json ${value}`, { silent: parsedOptions.silent })
    const output = <TerraformSingleOutput>JSON.parse(stdout)
    if (parsedOptions.simple) {
      return output.value
    }
    return output
  }

  public async getOutputKeys(path: string, options: ExecuteOptions = {}): Promise<string[]> {
    const { stdout } = await this.executeSync(path, 'output -json', { silent: options.silent || true })
    const output = JSON.parse(stdout)
    return Object.keys(output)
  }

  public async plan(path: string, options: ExecuteOptions = {}): Promise<ResourceCounts> {
    const { stdout } = await this.executeSync(path, 'plan', { silent: options.silent || false })
    return this.parseResourceChanges(stdout, ChangeTypes.PLAN)
  }

  public async destroy(path: string, options: DestroyOptions = {}): Promise<ResourceCounts> {
    const { stdout } = await this.executeInteractive('destroy', path, options)
    return this.parseResourceChanges(stdout, ChangeTypes.DESTROYED)
  }

  public async apply(path: string, options: ApplyOptions = {}): Promise<ResourceCounts> {
    const { stdout } = await this.executeInteractive('apply', path, options)
    return this.parseResourceChanges(stdout, ChangeTypes.ADDED)
  }

  private parseResourceChanges(rawStringWithResourceChanges: string, command: ChangeTypes): ResourceCounts {
    if (rawStringWithResourceChanges.includes('No changes')) {
      return {
        addCount: 0,
        changeCount: 0,
        destroyCount: 0
      }
    }
    let regexp: RegExp = / /
    switch (command) {
      case ChangeTypes.PLAN:
        regexp = new RegExp('Plan: (\\d*) to add, (\\d*) to change, (\\d*) to destroy', 'gi')
        break
      case ChangeTypes.ADDED:
        regexp = new RegExp('Apply complete! Resources: (\\d*) added, (\\d*) changed, (\\d*) destroyed', 'gi')
        break
      case ChangeTypes.DESTROYED:
        regexp = new RegExp('Destroy complete! Resources: (\\d) destroyed')
        break
    }
    const resourcesChangesWithoutStyles = rawStringWithResourceChanges.replace(/\u001b\[.*?m/g, '')
    const matches = regexp.exec(resourcesChangesWithoutStyles)

    if (matches) {
      if (command === ChangeTypes.DESTROYED) {
        return {
          addCount: 0,
          changeCount: 0,
          destroyCount: parseInt(matches[1], 10)
        }
      }
      return {
        addCount: parseInt(matches[1], 10),
        changeCount: parseInt(matches[2], 10),
        destroyCount: parseInt(matches[3], 10)
      }
    }
    throw new Error(`Could not extract added, changed and destroyed count with regexp ${regexp} from command ${rawStringWithResourceChanges}`)
  }
}

export { Terraform }
